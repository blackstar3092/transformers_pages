---
title: Calendar
permalink: /student/calendar
tailwind: true
layout: aesthetihawk
active_tab: calendar
---
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.0/main.min.css">

<style>
/* Override FullCalendar backgrounds with theme colors */
.fc {
  background-color: var(--bg-0);
}

.fc .fc-view-harness {
  background-color: var(--bg-0);
}

.fc-theme-standard td,
.fc-theme-standard th {
  background-color: var(--bg-0);
  border-color: var(--accent);
}

.fc-theme-standard .fc-scrollgrid {
  border-color: var(--accent);
}

/* Alternating row backgrounds */
.fc-daygrid-day {
  background-color: var(--bg-0);
}

.fc-daygrid-day:nth-child(even) {
  background-color: var(--bg-1);
}

/* Header styling */
.fc .fc-col-header-cell {
  background-color: var(--bg-2);  
  color: var(--text);
  border-bottom: none;
}

/* Day cells */
.fc .fc-daygrid-day-number {
  color: var(--text);
}

/* Remove top border from day grid body to prevent double line */
.fc .fc-daygrid-body {
  border-top: none;
}

/* Today highlighting */
.fc .fc-day-today {
  background-color: color-mix(in srgb, var(--accent) 20%, var(--bg-0) 80%) !important;
}
/* Break day highlighting */
.fc-event-break {
  background-color: #2a2a2a !important;
  border-color: transparent !important;
  border: none !important;
  box-shadow: none !important;
}

.fc-daygrid-day.break-day {
  background-color: #2a2a2a !important;
}
/* Priority-based event colors - saturated colors with white text */
.fc-event.priority-p0 {
  background-color: #dc2626 !important; /* Red 600 */
  border-color: #b91c1c !important;
  color: white !important;
}

.fc-event.priority-p1 {
  background-color: #ea580c !important; /* Orange 600 */
  border-color: #c2410c !important;
  color: white !important;
}

.fc-event.priority-p2 {
  background-color: #ca8a04 !important; /* Yellow 600 */
  border-color: #a16207 !important;
  color: white !important;
}

.fc-event.priority-p3 {
  background-color: #16a34a !important; /* Green 600 */
  border-color: #15803d !important;
  color: white !important;
}

/* Priority badge in event title */
.event-priority-badge {
  display: inline-block;
  font-size: 10px;
  font-weight: bold;
  padding: 1px 4px;
  border-radius: 3px;
  margin-right: 4px;
  vertical-align: middle;
}

.event-priority-badge.p0 { background: #dc2626; color: white; }
.event-priority-badge.p1 { background: #ea580c; color: white; }
.event-priority-badge.p2 { background: #ca8a04; color: white; }
.event-priority-badge.p3 { background: #16a34a; color: white; }
</style>

<!-- FullCalendar Container -->
<div id="calendar" class="box-border z-0"></div>
<!-- Modal -->
<div id="eventModal" class="fixed z-[99999] inset-0 flex items-center justify-center bg-opacity-70 backdrop-blur-sm pt-12 hidden">
    <div class="relative mx-auto my-12 p-8 rounded-2xl shadow-2xl max-w-xl min-h-fit w-full font-sans modal-content">
        <span class="text-gray-400 absolute right-8 top-6 text-3xl font-bold cursor-pointer transition-colors duration-300 hover:text-red-600" id="closeModal">&times;</span>
        <div class="modal-body">
            <h2 id="eventTitle" class="text-4xl font-bold mb-6"></h2>
            <label for="editDate" class="block mt-2 mb-1 text-lg font-semibold">Date:</label>
            <p id="editDateDisplay" contentEditable='false' class="w-full p-3 rounded-xl border border-gray-700 text-base box-border mb-4"></p>
            <input type="date" id="editDate" style="display: none;" class="w-full p-3 rounded-xl border border-gray-700 text-base box-border mb-4">
            <label for="editTitle" class="block mt-2 mb-1 text-lg font-semibold">Title:</label>
            <p id="editTitle" contentEditable='false' class="w-full p-3 rounded-xl border border-gray-700 text-base box-border mb-4"></p>
            <label for="editDescription" class="block mt-2 mb-1 text-lg font-semibold">Description:</label>
            <p id="editDescription" contentEditable='false' class="w-full p-3 rounded-xl border border-gray-700 text-base box-border mb-4 whitespace-pre-wrap"></p>
            <label for="editPeriod" class="block mt-2 mb-1 text-lg font-semibold">Class:</label>
            <select id="editPeriod" disabled class="w-full p-3 rounded-xl border border-gray-700 text-base box-border mb-4">
                <option value="CSP">CSP</option>
                <option value="CSA">CSA</option>
                <option value="CSSE">CSSE</option>
            </select>
            <label for="editPriority" class="block mt-2 mb-1 text-lg font-semibold">Priority:</label>
            <select id="editPriority" disabled class="w-full p-3 rounded-xl border border-gray-700 text-base box-border mb-4">
                <option value="P0" class="bg-red-200 text-red-900">P0 - Critical</option>
                <option value="P1" class="bg-orange-200 text-orange-900">P1 - High</option>
                <option value="P2" class="bg-yellow-200 text-yellow-900" selected>P2 - Medium</option>
                <option value="P3" class="bg-green-200 text-green-900">P3 - Low</option>
            </select>
        <div class="modal-actions">
            <button id="saveButton" class="w-full p-3 bg-red-700 rounded-xl text-base font-bold cursor-pointer transition duration-200 hover:bg-red-900 mt-2 hidden">Save Changes</button>
            <button id="makeBreakButton" class="w-full p-3 bg-yellow-600 rounded-xl text-base font-bold cursor-pointer transition duration-200 hover:bg-yellow-800 mt-2 hidden">Make Break</button>
            <button id="deleteButton" class="w-full p-3 bg-red-700 rounded-xl text-base font-bold cursor-pointer transition duration-200 hover:bg-red-900 mt-2">Delete Event</button>
            <button id="editButton" class="w-full p-3 bg-red-700 rounded-xl text-base font-bold cursor-pointer transition duration-200 hover:bg-red-900 mt-2">Edit Event</button>
        </div>
    </div>
</div>

<!-- FullCalendar JS -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.0/main.min.js"></script>
<script type="module">
    import { javaURI, fetchOptions } from '{{site.baseurl}}/assets/js/api/config.js';
    let allEvents = []; // Global array to store all events
    let currentFilter = null; // Track the current filter
    document.addEventListener("DOMContentLoaded", function () {
        let currentEvent = null;
        let isAddingNewEvent = false;
        let calendar;
        function isBreakDay(dateString) {
            // Check if the given date is a break day by looking at allEvents
            const breakEvent = allEvents.find(event => {
                const isBreak = (event.extendedProps && event.extendedProps.isBreak === true) || event.isBreak === true;
                const dateMatch = formatDate(event.start) === dateString;
                console.log(`Checking event: ${event.title}, isBreak: ${isBreak}, dateMatch: ${dateMatch}, eventDate: ${event.start}, checkDate: ${dateString}`);
                return isBreak && dateMatch;
            });
            console.log(`isBreakDay(${dateString}): ${breakEvent ? 'YES' : 'NO'}`, breakEvent);
            return !!breakEvent;
        }
        function getBreakName(dateString) {
            // Get the break name for a given date (robust for either top-level or extendedProps storage)
            const breakEvent = allEvents.find(event => {
                const isBreak = (event.extendedProps && event.extendedProps.isBreak === true) || event.isBreak === true;
                return isBreak && formatDate(event.start) === dateString;
            });
            if (!breakEvent) return null;
            return (breakEvent.extendedProps && breakEvent.extendedProps.breakName) || breakEvent.breakName || breakEvent.title || null;
        }
        function request() {
            return fetch(`${javaURI}/api/calendar/events`, fetchOptions)
                .then(response => {
                    if (response.status !== 200) {
                        console.error("HTTP status code: " + response.status);
                        return null;
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error("Fetch error: ", error);
                    return null;
                });
        }
        // getAssignments removed - assignments are no longer fetched here
        function getBreaks() {
            // Try primary endpoint, then fallback to trailing slash if 404 (some servers require it)
            return fetch(`${javaURI}/api/calendar/breaks`, fetchOptions)
                .then(response => {
                    if (response.status === 404) {
                        console.warn('Breaks endpoint returned 404, retrying with trailing slash');
                        return fetch(`${javaURI}/api/calendar/breaks/`, fetchOptions);
                    }
                    return response;
                })
                .then(response => {
                    if (!response || response.status !== 200) {
                        console.error("HTTP status code for breaks: " + (response && response.status));
                        return [];
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error("Fetch error for breaks: ", error);
                    return [];
                });
        }
        function handleRequest() {
            Promise.all([request(), getBreaks()])
                .then(([calendarEvents, breaks]) => {
                    console.log("handleRequest - All data loaded. Breaks:", breaks);
                    allEvents = []; // Reset allEvents
                    if (calendarEvents !== null) {
                        calendarEvents.forEach(event => {
                            try {
                                // Extract priority from title if present (format: [P0], [P1], [P2], [P3])
                                let priority = event.priority || 'P2';
                                let displayTitle = event.title || '';
                                // Check if title starts with priority tag like [P0], [P1], etc.
                                const priorityMatch = displayTitle.match(/^\[(P[0-3])\]\s*/);
                                if (priorityMatch) {
                                    priority = priorityMatch[1];
                                    displayTitle = displayTitle.replace(/^\[(P[0-3])\]\s*/, ''); // Remove priority tag from display
                                }
                                // Priority-based colors (saturated for white text)
                                const priorityColors = {
                                    'P0': '#dc2626', // Red 600
                                    'P1': '#ea580c', // Orange 600
                                    'P2': '#ca8a04', // Yellow 600
                                    'P3': '#16a34a'  // Green 600
                                };
                                let color = priorityColors[priority] || "#808080";
                                // Fall back to class-based colors if no priority detected
                                if (!priorityMatch && !event.priority) {
                                    if (event.class == "CSP") {
                                        color = "#3788d8";
                                    } else if (event.class == "CSSE") {
                                        color = "#008000";
                                    }
                                }
                                allEvents.push({
                                    id: event.id,
                                    period: event.period || null,
                                    priority: priority,
                                    title: displayTitle.replace(/\(P[13]\)/gi, ""),
                                    description: event.description,
                                    // Normalize stored start to YYYY-MM-DD to avoid timezone parsing as UTC
                                    start: formatDate(event.date),
                                    color: color,
                                    isBreak: false,
                                    classNames: [`priority-${priority.toLowerCase()}`]
                                });
                            } catch (err) {
                                console.error("Error loading calendar event:", event, err);
                            }
                        });
                    }
                    // assignments removed from frontend; no processing here
                    if (breaks && breaks.length > 0) {
                        console.log("Breaks loaded:", breaks);
                        breaks.forEach(breakItem => {
                            try {
                                const breakEvent = {
                                    id: breakItem.id,
                                    // Title kept for compatibility but primary name stored in extendedProps.breakName
                                    title: `Break: ${breakItem.name || 'Break'}`,
                                    description: breakItem.description || breakItem.name || 'Break',
                                    // Normalize break date to YYYY-MM-DD local representation
                                    start: formatDate(breakItem.date),
                                    backgroundColor: "#2a2a2a",
                                    borderColor: "#1a1a1a",
                                    textColor: "#ffffff",
                                    // Mark consistently on both extendedProps and top-level for different code paths
                                    isBreak: true,
                                    breakName: breakItem.name || 'Break',
                                    extendedProps: {
                                        isBreak: true,
                                        breakName: breakItem.name || 'Break',
                                        description: breakItem.description || ''
                                    },
                                    classNames: ['fc-event-break']
                                };
                                console.log("Adding break event:", breakEvent);
                                allEvents.push(breakEvent);
                            } catch (err) {
                                console.error("Error loading break:", breakItem, err);
                            }
                        });
                    } else {
                        console.log("No breaks found");
                    }
                    displayCalendar(filterEventsByClass(currentFilter)); // Display filtered events
                });
        }
        function displayCalendar(events) {
            const calendarEl = document.getElementById('calendar');
            if (calendar) {
                calendar.destroy(); // Destroy the existing calendar instance
            }
            calendar = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                headerToolbar: {
                    left: 'prev,next today allButton,csaButton,cspButton,csseButton',
                    center: 'title',
                    right: 'dayGridMonth,dayGridWeek,dayGridDay'
                },
                customButtons: {
                    allButton: {
                        text: 'All',
                        click: function () {
                            currentFilter = null;
                            displayCalendar(filterEventsByClass(currentFilter));
                        }
                    },
                    csaButton: {
                        text: 'CSA',
                        click: function () {
                            currentFilter = "CSA";
                            displayCalendar(filterEventsByClass(currentFilter));
                        }
                    },
                    cspButton: {
                        text: 'CSP',
                        click: function () {
                            currentFilter = "CSP";
                            displayCalendar(filterEventsByClass(currentFilter));
                        }
                    },
                    csseButton: {
                        text: 'CSSE',
                        click: function () {
                            currentFilter = "CSSE";
                            displayCalendar(filterEventsByClass(currentFilter));
                        }
                    }
                },
                views: {
                    dayGridMonth: { buttonText: 'Month' },
                    dayGridWeek: { buttonText: 'Week' },
                    dayGridDay: { buttonText: 'Day' }
                },
                // Highlight break days (no text in the cell; the break event shows the name)
                dayCellDidMount: function(arg) {
                    try {
                        const dateStr = formatDate(arg.date);
                        if (isBreakDay(dateStr)) {
                            arg.el.classList.add('break-day');
                        } else {
                            arg.el.classList.remove('break-day');
                        }
                    } catch (e) {
                        console.error('dayCellDidMount error:', e);
                    }
                },
                events: events,
                eventClick: function (info) {
                    document.getElementById("saveButton").style.display = "none";
                    document.getElementById("makeBreakButton").style.display = "none";
                    currentEvent = info.event;
                    // When an existing event is clicked, this is not an 'add' flow
                    isAddingNewEvent = false;
                    const isBreak = (currentEvent.extendedProps && currentEvent.extendedProps.isBreak === true) || currentEvent.isBreak === true;
                    console.log("Event clicked:", currentEvent.title, "isBreak:", isBreak);
                    document.getElementById('eventTitle').textContent = currentEvent.title;
                    document.getElementById('editTitle').innerHTML = isBreak ? ((currentEvent.extendedProps && currentEvent.extendedProps.breakName) || currentEvent.breakName || currentEvent.title) : currentEvent.title;
                    document.getElementById('editDescription').innerHTML = slackToHtml(currentEvent.extendedProps.description || "");
                    document.getElementById('editDateDisplay').textContent = formatDisplayDate(currentEvent.start);
                    document.getElementById('editDate').value = formatDate(currentEvent.start);
                    document.getElementById("editPeriod").value = currentEvent.extendedProps.period || "";
                    document.getElementById("editPeriod").disabled = true;
                    document.getElementById("editPriority").value = currentEvent.extendedProps.priority || "P2";
                    document.getElementById("editPriority").disabled = true;
                    document.getElementById("eventModal").style.display = "block";
                    // Check if this is a break event
                    if (isBreak) {
                        // For break events, show edit and delete buttons
                        document.getElementById("deleteButton").style.display = "inline-block";
                        document.getElementById("editButton").style.display = "inline-block";
                        document.getElementById("makeBreakButton").style.display = "none";
                        document.getElementById("eventModal").dataset.isBreak = "true";
                    } else {
                        // For regular events, show edit and delete buttons
                        document.getElementById("deleteButton").style.display = "inline-block";
                        document.getElementById("editButton").style.display = "inline-block";
                        document.getElementById("eventModal").dataset.isBreak = "false";
                    }
                },
                dateClick: function (info) {
                    const selectedDate = formatDate(info.date);
                    // Check if this date is a break day
                    if (isBreakDay(selectedDate)) {
                        alert(`There is already a break on ${formatDisplayDate(info.date)}`);
                        return;
                    }
                    isAddingNewEvent = true;
                    document.getElementById("eventTitle").textContent = "Add New Event";
                    document.getElementById("editTitle").innerHTML = "";
                    document.getElementById("editDescription").innerHTML = "";
                    document.getElementById("editDescription").contentEditable = true;
                    document.getElementById("editTitle").contentEditable = true;
                    document.getElementById("editPeriod").disabled = false; // Enable period dropdown for new events
                    document.getElementById("editPriority").disabled = false; // Enable priority dropdown for new events
                    document.getElementById("editPriority").value = "P2"; // Default to medium priority
                    document.getElementById('editDateDisplay').textContent = formatDisplayDate(info.date);
                    document.getElementById('editDate').value = selectedDate;
                    document.getElementById("eventModal").style.display = "block";
                    document.getElementById("deleteButton").style.display = "none";
                    document.getElementById("editButton").style.display = "none";
                    document.getElementById("saveButton").style.display = "inline-block";
                    document.getElementById("makeBreakButton").style.display = "inline-block";
                    document.getElementById("saveButton").onclick = function () {
                        const updatedTitle = document.getElementById("editTitle").innerHTML.trim();
                        const updatedDescription = document.getElementById("editDescription").innerHTML;
                        const updatedDate = document.getElementById("editDate").value;
                        const updatedPriority = document.getElementById("editPriority").value;
                        if (!updatedTitle || !updatedDescription || !updatedDate) {
                            alert("Title, Description, and Date cannot be empty!");
                            return;
                        }
                        // Priority-based colors (saturated for white text)
                        const priorityColors = {
                            'P0': '#dc2626', 'P1': '#ea580c', 'P2': '#ca8a04', 'P3': '#16a34a'
                        };
                        const newEventPayload = {
                            title: updatedTitle,
                            description: updatedDescription,
                            date: updatedDate,
                            period: document.getElementById("editPeriod").value, // Event class (CSA, CSP, CSSE)
                            priority: updatedPriority
                        };
                        const newEvent = {
                            id: Date.now().toString(), // Generate a unique ID
                            title: updatedTitle,
                            description: updatedDescription,
                            start: updatedDate,
                            period: document.getElementById("editPeriod").value, // Assign the current filter (CSA, CSP, CSSE)
                            priority: updatedPriority,
                            color: priorityColors[updatedPriority] || "#808080",
                            classNames: [`priority-${updatedPriority.toLowerCase()}`]
                        };
                        allEvents.push(newEvent); // Add to allEvents
                        displayCalendar(filterEventsByClass(currentFilter)); // Refresh calendar
                        document.getElementById("eventModal").style.display = "none";
                        fetch(`${javaURI}/api/calendar/add_event`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(newEventPayload),
                        })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Failed to add new event: ${response.status} ${response.statusText}`);
                            }
                            return response.json();
                        })
                        .then(() => {
                            // Re-fetch events from the backend to ensure the calendar is up-to-date
                            handleRequest();
                            document.getElementById("eventModal").style.display = "none";
                        })
                        .catch(error => {
                            console.error("Error adding event:", error);
                        });
                    };
                },
                // eventMouseEnter: function (info) {
                //     const tooltip = document.createElement('div');
                //     tooltip.className = 'event-tooltip';
                //     tooltip.innerHTML = `<strong>${info.event.title}</strong><br>${info.event.extendedProps.description || ''}`;
                //     document.body.appendChild(tooltip);
                //     tooltip.style.left = info.jsEvent.pageX + 'px';
                //     tooltip.style.top = info.jsEvent.pageY + 'px';
                // },
                // eventMouseLeave: function () {
                //     const tooltips = document.querySelectorAll('.event-tooltip');
                //     tooltips.forEach(tooltip => tooltip.remove());
                // }
            });
            calendar.render();
        }
        function filterEventsByClass(className) {
            let filtered = allEvents;
            if (className) {
                // Include break events regardless of filter, plus filtered regular events
                filtered = allEvents.filter(event => {
                    const isBreak = event.extendedProps && event.extendedProps.isBreak === true;
                    return isBreak || event.period === className;
                });
            }
            // Sort by priority (P0 first, then P1, P2, P3), breaks are not prioritized
            return filtered.sort((a, b) => {
                // Breaks always come first
                const aIsBreak = a.extendedProps && a.extendedProps.isBreak === true;
                const bIsBreak = b.extendedProps && b.extendedProps.isBreak === true;
                if (aIsBreak && !bIsBreak) return -1;
                if (!aIsBreak && bIsBreak) return 1;
                if (aIsBreak && bIsBreak) return 0;
                // For non-break events, sort by priority
                const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
                const aPriority = priorityOrder[a.priority] ?? 2;
                const bPriority = priorityOrder[b.priority] ?? 2;
                return aPriority - bPriority;
            });
        }
        function formatDate(dateInput) {
            // If already a YYYY-MM-DD string, return as-is to avoid UTC parsing issues
            if (!dateInput && dateInput !== 0) return '';
            if (typeof dateInput === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(dateInput)) return dateInput;
            const d = (dateInput instanceof Date) ? dateInput : new Date(dateInput);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        document.getElementById("closeModal").onclick = function () {
            document.getElementById('editDateDisplay').style.display = 'block';
            document.getElementById('editDateDisplay').style.display = 'block';
            document.getElementById('editDate').style.display = 'none';
            document.getElementById("saveButton").style.display = "none";
            document.getElementById("eventModal").style.display = "none";
            document.getElementById("editTitle").contentEditable = false;
            document.getElementById("editDescription").contentEditable = false;
            document.getElementById("eventModal").style.display = "none";
        };
        document.getElementById("saveButton").onclick = function () {
            const isBreak = document.getElementById("eventModal").dataset.isBreak === "true";
            const updatedTitle = document.getElementById("editTitle").innerHTML.trim();
            const updatedDescription = document.getElementById("editDescription").innerHTML;          
            // Reset UI state
            document.getElementById("saveButton").style.display = "none";
            document.getElementById('editDateDisplay').style.display = 'block';
            document.getElementById('editDate').style.display = 'none';
            document.getElementById("editDescription").contentEditable = false;
            document.getElementById("editTitle").contentEditable = false;
            document.getElementById("editPeriod").disabled = true;
            document.getElementById("editPriority").disabled = true;      
            if (!updatedTitle || !updatedDescription) {
                alert("Title and Description cannot be empty!");
                return;
            }     
            if (isBreak) {
                // Handle break editing
                const id = currentEvent.id;
                const breakPayload = {
                    name: updatedTitle,
                    description: updatedDescription
                };                
                fetch(`${javaURI}/api/calendar/breaks/${id}`, {
                    method: "PUT",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(breakPayload),
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to update break: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(() => {
                    document.getElementById("eventModal").style.display = "none";
                    handleRequest();
                })
                .catch(error => {
                    console.error("Error updating break:", error);
                    alert("Failed to update break. Please try again.\n\nError: " + error.message);
                });
            } else {
                // Handle regular event editing
                const updatedPeriod = document.getElementById("editPeriod").value;
                const updatedPriority = document.getElementById("editPriority").value;
                const updatedDate = document.getElementById("editDate").value;
                const priorityColors = {
                    'P0': '#fecaca', 'P1': '#fed7aa', 'P2': '#fef08a', 'P3': '#bbf7d0'
                };    
                document.getElementById('editDateDisplay').textContent = formatDisplayDate(new Date(updatedDate));
                if (!updatedDate) {
                    alert("Date cannot be empty!");
                    return;
                }
                if (isAddingNewEvent) {
                    const newEventPayload = {
                        title: updatedTitle,
                        description: updatedDescription,
                        date: updatedDate,
                        period: updatedPeriod,
                        priority: updatedPriority
                    }; 
                    fetch(`${javaURI}/api/calendar/add_event`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(newEventPayload),
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to add new event: ${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(() => {
                        document.getElementById("eventModal").style.display = "none";
                        handleRequest();
                    })
                    .catch(error => {
                        console.error("Error adding event:", error);
                        alert("Failed to add event. Please try again.\n\nError: " + error.message);
                    });
                } else {
                    const payload = { newTitle: updatedTitle, description: updatedDescription, date: updatedDate, period: updatedPeriod, priority: updatedPriority };
                    const id = currentEvent.id;
                    fetch(`${javaURI}/api/calendar/edit/${id}`, {
                        method: "PUT",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload),
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to update event: ${response.status} ${response.statusText}`);
                        }
                        return response.text();
                    })
                    .then(() => {
                        document.getElementById("eventModal").style.display = "none";
                        handleRequest();
                    })
                    .catch(error => {
                        console.error("Error updating event:", error);
                        alert("Failed to update event. Please try again.\n\nError: " + error.message);
                    });
                }
            }
        };
        document.getElementById("editButton").onclick = function () {
            const isBreak = document.getElementById("eventModal").dataset.isBreak === "true";
            document.getElementById('editDateDisplay').style.display = 'none';
            document.getElementById('editDate').style.display = isBreak ? 'none' : 'block';
            document.getElementById("deleteButton").style.display = 'none';
            document.getElementById("saveButton").style.display = 'inline-block';
            document.getElementById("editDescription").contentEditable = true;
            document.getElementById("editTitle").contentEditable = true;
            // Editing an existing event should not create a new one
            isAddingNewEvent = false;
            if (!isBreak) {
                document.getElementById("editPeriod").disabled = false;
                document.getElementById("editPriority").disabled = false;
            }
            document.getElementById("editDescription").innerHTML = currentEvent.extendedProps.description || "";
        };
        document.getElementById("deleteButton").onclick = function () {
            if (!currentEvent) return;
            const isBreak = document.getElementById("eventModal").dataset.isBreak === "true";
            const id = currentEvent.id;
            const confirmation = confirm(`Are you sure you want to delete "${currentEvent.title}"?`);
            if (!confirmation) return;
            const endpoint = isBreak ? `${javaURI}/api/calendar/breaks/${id}` : `${javaURI}/api/calendar/delete/${id}`;
            fetch(endpoint, {
                method: "DELETE",
                headers: { "Content-Type": "application/json" }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to delete: ${response.status} ${response.statusText}`);
                }
                return response.text();
            })
            .then(() => {
                currentEvent.remove();
                document.getElementById("eventModal").style.display = "none";
                handleRequest();
            })
            .catch(error => {
                console.error("Error deleting:", error);
                alert("Failed to delete. Please try again.\n\nError: " + error.message);
            });
        };
        document.getElementById("makeBreakButton").onclick = function () {
            const breakDate = document.getElementById("editDate").value;
            const breakTitle = document.getElementById("editTitle").innerHTML.trim();
            const breakDescription = document.getElementById("editDescription").innerHTML;
            console.log("Break creation - Title:", breakTitle, "Date:", breakDate, "Description:", breakDescription);
            if (!breakDate) {
                alert("Please select a date for the break!");
                return;
            }
            if (!breakTitle) {
                alert("Please enter a name for the break!");
                return;
            }
            // Check if a break already exists on this date
            if (isBreakDay(breakDate)) {
                alert(`There is already a break on ${formatDisplayDate(new Date(breakDate.split('-').map(Number)[0], breakDate.split('-').map(Number)[1] - 1, breakDate.split('-').map(Number)[2]))}`);
                return;
            }
            // Parse date string safely to avoid timezone issues
            const [year, month, day] = breakDate.split('-').map(Number);
            const localDate = new Date(year, month - 1, day);
            const confirmation = confirm(`Are you sure you want to make ${formatDisplayDate(localDate)} a break day with the name "${breakTitle}"? Events on this day will be moved to the next non-break day.`);
            if (!confirmation) return;
            const breakPayload = {
                date: breakDate,
                name: breakTitle,
                description: breakDescription,
                moveToNextNonBreakDay: true
            };
            console.log("Sending break payload:", breakPayload);
            fetch(`${javaURI}/api/calendar/breaks/create`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(breakPayload),
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        throw new Error(`Failed to create break: ${response.status} ${response.statusText} - ${text}`);
                    });
                }
                return response.json();
            })
            .then((result) => {
                console.log("Break creation response:", result);
                alert("Break day created successfully. Events on this day have been moved to the next non-break day.");
                document.getElementById("eventModal").style.display = "none";
                handleRequest(); // Refresh the calendar
            })
            .catch(error => {
                console.error("Error creating break:", error);
                alert("Failed to create break day. Please try again.\n\nError: " + error.message);
            });
        };
        handleRequest();
    });
    document.addEventListener('keydown', function (event) {
        if (event.key === 'Escape') {
            document.getElementById('editDateDisplay').style.display = 'block';
            document.getElementById('editDate').style.display = 'none';
            document.getElementById("saveButton").style.display = "none";
            document.getElementById("eventModal").style.display = "none";
            document.getElementById("editTitle").contentEditable = false;
            document.getElementById("editDescription").contentEditable = false;
        }
    });
    window.onclick = function (event) {
        const modal = document.getElementById("eventModal");
        if (event.target === modal) {
            document.getElementById('editDateDisplay').style.display = 'block';
            document.getElementById('editDate').style.display = 'none';
            document.getElementById("saveButton").style.display = "none";
            document.getElementById("eventModal").style.display = "none";
            document.getElementById("editTitle").contentEditable = false;
            document.getElementById("editDescription").contentEditable = false;
            modal.style.display = "none";
        }
    };
    function slackToHtml(text) {
        if (!text) return '';
        // First pass - handle code blocks to prevent their content from being processed
        let processed = text;
        const codeBlocks = [];
        processed = processed.replace(/```([\s\S]*?)```/g, (match, content) => {
            codeBlocks.push(content);
            return `%%CODEBLOCK${codeBlocks.length-1}%%`;
        });
        // Second pass - handle inline code
        const inlineCodes = [];
        processed = processed.replace(/`([^`]+)`/g, (match, content) => {
            inlineCodes.push(content);
            return `%%INLINECODE${inlineCodes.length-1}%%`;
        })
        // Third pass - handle links
        const links = [];
        processed = processed.replace(/<((https?|ftp|mailto):[^|>]+)(?:\|([^>]+))?>/g, (match, url, protocol, text) => {
            const linkText = text || url;
            links.push({url, linkText});
            return `%%LINK${links.length-1}%%`;
        });
        // Process formatting (bold, italic, strikethrough) with nesting support
        processed = processed
            .replace(/(\*)([^*]+)\1/g, '<strong>$2</strong>')
            .replace(/(_)([^_]+)\1/g, '<em>$2</em>')
            .replace(/(~)([^~]+)\1/g, '<del>$2</del>');
        // Restore code blocks
        processed = processed.replace(/%%CODEBLOCK(\d+)%%/g, (match, index) => {
            return `<pre><code>${escapeHtml(codeBlocks[index])}</code></pre>`;
        });
        // Restore inline code
        processed = processed.replace(/%%INLINECODE(\d+)%%/g, (match, index) => {
            return `<code>${escapeHtml(inlineCodes[index])}</code>`;
        });
        // Restore links
        processed = processed.replace(/%%LINK(\d+)%%/g, (match, index) => {
            const {url, linkText} = links[index];
            return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener">${escapeHtml(linkText)}</a>`;
        });
        // Convert newlines to <br> and preserve multiple newlines
        processed = processed.replace(/\n/g, '<br>');
        return processed;
    }
    // Helper function to escape HTML special characters
    function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
    function formatDisplayDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
    }
</script>